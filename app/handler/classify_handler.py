import numpy as np
import pandas as pd
from flask import Flask, jsonify, request
from matplotlib import pyplot
import matplotlib.pyplot as plt
from tensorflow.keras import Model, Sequential
from tensorflow.keras.models import Sequential, Model, load_model
from tensorflow.keras.layers import Input, Dropout, Activation, Dense
from tensorflow.keras.optimizers import Adadelta
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.layers import Dense, Dropout
from sklearn.metrics import classification_report, accuracy_score, recall_score, precision_score, f1_score
from sklearn.preprocessing import MinMaxScaler, LabelEncoder

# Load the dataset
def import_dataset(filepath):
    df = pd.read_csv(filepath)
    return df

# Preprocess the dataset
def preprocess_dataset(df):
    vc = df["label"].value_counts()
    print(f"Value counts: {vc}")

    df.sort_values(by='ts', inplace=True)
    df['time_diff'] = df['ts'].diff()

    columns_to_drop = ['Unnamed: 0','ts', 'uid', 'id.orig_h', 'local_orig', 'local_resp', 'missed_bytes','history','service',
                    'id.orig_p','id.resp_p','service','duration']
    df.drop(columns=columns_to_drop, inplace=True)

    # Encode labels
    data = {'label': ['PartOfAHorizontalPortScan', 'Okiru', 'Benign',
                  'DDoS', 'C&C', 'C&C-HeartBeat','C&C-FileDownload','Okiru-Attack']}
    labeldata = pd.DataFrame(data)
    label_encoder = LabelEncoder()
    df['label'] = label_encoder.fit_transform(df['label'])
    df['label'] = df['label'].apply(lambda x: 0 if x == label_encoder.transform(['Benign'])[0] else 1)

    columns_to_drop = ['orig_bytes', 'resp_bytes', 'resp_pkts', 'resp_ip_bytes']
    df.drop(columns=columns_to_drop, inplace=True)

    df=df.fillna({'time_diff':'0'})

    proto_mapping = {'tcp': 1, 'udp': 2, 'icmp': 3}  
    conn_state_mapping = {'S0': 1, 'S1': 2, 'S3': 3, 
                        'REJ': 4, 'SF': 5, 'OTH': 6, 'RSTO': 7, 'RSTR': 8} 
    df['proto_encoded'] = df['proto'].map(proto_mapping)
    df['conn_state_encoded'] = df['conn_state'].map(conn_state_mapping)
    df.drop(['proto', 'conn_state'], axis=1, inplace=True)

    df.drop(columns=['id.resp_h'], inplace = True)

    missing_data = df[df['conn_state_encoded'].isnull()]
    print(missing_data)

    columns_to_normalize = ['orig_pkts', 'orig_ip_bytes', 'time_diff', 'proto_encoded','conn_state_encoded']
    scaler = MinMaxScaler()
    df[columns_to_normalize] = scaler.fit_transform(df[columns_to_normalize])

    return df

def train_model(X, Y, model_path, df):
    from sklearn.model_selection import train_test_split
    from keras.optimizers import Adam
    from keras.callbacks import EarlyStopping
    from keras.callbacks import ModelCheckpoint

    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, random_state=10, test_size=0.2)
    model = Sequential()
    model.add(Dense(1000, activation='relu',input_dim=5))
    model.add(Dense(500, activation='relu'))
    model.add(Dropout(0.2))
    model.add(Dense(1, activation='sigmoid'))

    learning_rate = 0.001
    optimizer = Adam(learning_rate=learning_rate)
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=['accuracy'])


    es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=5)
    model.save(model_path)

    plt.figure()
    label_counts = df['label'].value_counts()
    plt.figure(figsize=(8, 6))
    label_counts.plot(kind='bar', color=['blue', 'red'])  
    plt.title('Distribusi Kelas')
    plt.xlabel('Kelas')
    plt.ylabel('Jumlah')
    plt.xticks([0, 1], ['Benign', 'Malware'])
    plt.savefig('app/static/visualize/plot.png')

    history = model.fit(X_train, Y_train, validation_data=(X_test, Y_test), epochs = 20, batch_size=512,  verbose=1, callbacks=[es])

    import seaborn as sns

    plt.figure()
    fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(14, 10), sharex=True)
    fig.suptitle('Feature Time Series by Label')
    axes = axes.flatten()
    features = ['orig_pkts', 'orig_ip_bytes', 'proto_encoded', 'conn_state_encoded']
    for i, feature in enumerate(features):
        sns.lineplot(ax=axes[i], data=df, x='time_diff', y=feature, hue='label', ci=None)
        axes[i].set_title(f'{feature} Over Time')
        axes[i].set_xlabel('Time Difference')
        axes[i].set_ylabel(feature)
    plt.tight_layout(rect=[0, 0, 1, 0.95])
    for j in range(i+1, len(axes)):
        axes[j].set_visible(False)
    plt.savefig('app/static/visualize/time_series.png')

    return  X_train, X_test, Y_train, Y_test, history

# Load the pre-trained model
def load_pretrained_model(model_path):
    from keras.models import load_model
    model = load_model(model_path)
    return model

# Predict labels
def predict_labels(model, X_train, X_test, Y_train, Y_test, history):
    # Evaluate the model
    print('Evaluating model...')
    pyplot.figure()
    _, train_acc = model.evaluate(X_train, Y_train, verbose=0)
    _, test_acc = model.evaluate(X_test, Y_test, verbose=0)
    print('Train: %.3f, Test: %.3f' % (train_acc, test_acc))
    # plot training history
    pyplot.plot(history.history['accuracy'], label='train')
    pyplot.plot(history.history['val_accuracy'], label='test')
    pyplot.legend()
    pyplot.savefig('app/static/visualize/monitoring.png')
    print('Model evaluation completed.')

    
    train_loss = history.history['loss']
    val_loss = history.history['val_loss']
    epochs = range(1, len(train_loss) + 1)

    plt.plot(epochs, train_loss, 'bo', label='Training Loss')
    plt.plot(epochs, val_loss, 'r', label='Validation Loss')
    plt.title('Training and Validation Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()
    plt.savefig('app/static/visualize/loss.png')

    Y_pred = model.predict(X_test)
    Y_pred_classes = (Y_pred > 0.5).astype(int)

    from sklearn.metrics import classification_report

    report = classification_report(Y_test, Y_pred_classes)
    print(report)
    return Y_pred_classes

# Evaluate the model
def evaluate_model(Y_test, Y_pred_classes):
    accuracy = accuracy_score(Y_test, Y_pred_classes)
    recall = recall_score(Y_test, Y_pred_classes)
    precision = precision_score(Y_test, Y_pred_classes)
    f1score = f1_score(Y_test, Y_pred_classes)
    report = classification_report(Y_test, Y_pred_classes)
    return accuracy, recall, precision, f1score, report
